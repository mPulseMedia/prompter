# Meta Project Structure and Rules

1. what_is_meta
	a. purpose
		1. Meta is a development system for cursor.ai.
		2. Builds web apps through sequential prompts.
		3. Enforces naming conventions via codename indexes.
		4. Provides browser-based editing interfaces.
	b. how_cursor_uses_it
		1. Reads rules from meta/rule folders.
		2. Follows prompt instructions from prompt folder.
		3. Generates code in app folder.
		4. Tracks all names in index files.
		5. Uses browser sync for real-time editing.

2. project_folders_explained
	a. prompt_folder
		1. Location is /prompt/ at project root.
		2. Contains master prompt files.
		3. 01_start.txt has current requirements.
		4. Cursor reads this to know what to build.
		5. Each prompt has numbered sections.
		6. Cursor executes prompts sequentially.
	b. app_folder
		1. Location is /app/ at project root.
		2. This is where cursor generates code.
		3. Starts empty until prompts are run.
		4. Will contain index.html and other files.
		5. All generated identifiers go in app_index.txt.
		6. Never edit these files manually.
	c. meta_folder
		1. Location is /meta/ at project root.
		2. Contains all system support files.
		3. Has rules, code, and configuration.
		4. Browser sync system lives here.
		5. Do not modify unless improving system.

3. meta_subfolders_explained
	a. meta_code_folder
		1. Location is meta/code/.
		2. Contains JavaScript for browser sync.
		3. sync/ has server and utilities.
			a. sync_server.js runs the sync server.
			b. html_extract.js processes HTML files.
			c. meta.sh manages browser windows.
		4. layout/ has browser UI templates.
			a. Templates for different view types.
			b. Client-side JavaScript for interactivity.
			c. Navigation and editing functionality.
	b. meta_html_folder
		1. Location is meta/html/.
		2. Generated by sync server automatically.
		3. DO NOT EDIT these files directly.
		4. Browser views of text files.
		5. Changes here sync back to text files.
	c. meta_src_folder
		1. Location is meta/src/.
		2. Contains source text files.
		3. tool/ has index, function, and web files.
			a. index.txt lists all codenames.
			b. function.txt shows function hierarchy.
			c. web.txt maps web relationships.
		4. prompt/ mirrors main prompt folder.
			a. 01_start.txt is duplicated here.
			b. Allows browser editing of prompts.
	d. meta_rule_folder
		1. Location is meta/rule/.
		2. Contains all formatting rules.
		3. tool/ has tool-specific rules.
			a. codename_index_rule.txt for indexes.
			b. function_rule.txt for functions.
			c. web_rule.txt for web relationships.
		4. other/ has general rules.
			a. rule_prompt.txt for executing prompts.
			b. rule_code.txt for JavaScript style.
			c. rule_codename.txt for naming.
	e. meta_layout_folder
		1. Location is meta/layout/.
		2. Contains layout format rules.
		3. layout_outline_rule.txt defines format.
		4. Used for structuring documents.
		5. Defines numbering and indentation.

4. how_cursor_should_use_folders
	a. reading_rules
		1. Start by checking .cursor/rules file.
		2. That points to this README.md.
		3. Read all files in meta/rule/.
		4. Apply rules when generating code.
		5. List which rules were used.
	b. executing_prompts
		1. Read prompt/01_start.txt.
		2. Find current execution marker.
		3. Execute next numbered section.
		4. Generate files in app folder.
		5. Update all relevant indexes.
		6. Move marker to next section.
	c. maintaining_indexes
		1. Check index.txt for meta names.
		3. Before creating new names, verify unique.
		4. Add all new names to appropriate index.
		5. Keep indexes sorted and organized.
	d. using_browser_sync
		1. Run sync server from meta/code/sync/.
		2. Opens browser windows automatically.
		3. Edit text files in browser interface.
		4. Changes save back to text files.
		5. Use for editing prompts and tools.

5. key_files_and_purposes
	a. index_files
		2. app_index.txt tracks app/ identifiers.
		3. Must be updated with every change.
		4. Prevents naming conflicts.
		5. Shows all codenames in use.
	b. prompt_files
		1. 01_start.txt is master prompt.
		2. Contains numbered requirements.
		3. Has execution markers.
		4. Guides app development.
		5. May reference epic file for context.
	c. rule_files
		1. Each rule file has specific purpose.
		2. Must be read before coding.
		3. Defines conventions to follow.
		4. Ensures consistent output.
		5. Listed with checkboxes in chat.

6. cursor_workflow
	a. initialization
		1. User types command in chat.
		2. Cursor reads this README.md.
		3. Loads all rule files.
		4. Checks current prompt status.
		5. Ready to execute tasks.
	b. prompt_execution
		1. Reads current prompt section.
		2. Applies relevant rules.
		3. Generates code in app folder.
		4. Updates all indexes.
		5. Reports which rules were used.
	c. browser_editing
		1. User runs sync server.
		2. Opens browser windows.
		3. Edits text in browser.
		4. Server syncs to text files.
		5. Cursor reads updated files.

7. human_understanding_guide
	a. system_overview
		1. Meta is like a smart template system.
		2. Rules ensure consistent code.
		3. Prompts are step-by-step instructions.
		4. Browser sync enables visual editing.
		5. Indexes prevent naming chaos.
	b. why_this_structure
		1. Separates rules from code from prompts.
		2. Makes system extensible.
		3. Enables browser-based workflows.
		4. Tracks everything systematically.
		5. Cursor knows exactly what to do.
	c. practical_usage
		1. Developers write prompts.
		2. Cursor reads prompts and rules.
		3. Generates app following conventions.
		4. Browser shows live previews.
		5. Everything stays organized.