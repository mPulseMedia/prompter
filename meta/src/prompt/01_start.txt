1. index_html_create
	a. Create basic HTML index page
		1. Create prompt/html/codename_index.html with minimal structure
		2. No title. Start with empty ul element with id="index_list"
		3. No styling or formatting yet
		4. Just basic HTML structure with DOCTYPE, html, head, body tags
	b. Create sync_server foundation
		1. Create meta/browser2/sync_server.js
		2. Add const http = require('http') and const fs = require('fs')
		3. Add const path = require('path') for file paths
		4. Create server on port 3002
		5. Add file_config object: { codename_index: { txt_path: path.join(...), html_path: path.join(...) } }
		6. Use absolute paths from project root

2. index_txt_read
	a. Add txt file reading
		1. Add fs module import to sync_server.js (already done in 1b)
		2. Add txt_read function that uses fs.readFileSync
		3. Split content by newlines into array
		4. Log array to console for verification
	b. Serve HTML files
		1. Add route handler for GET requests
		2. Check if requested path is in file_config
		3. Read and send the corresponding HTML file
		4. Set Content-Type: text/html header
		5. Return 404 for unknown paths

3. index_txt_to_html
	a. Add txt to HTML update
		1. Create txt_to_html_update function in sync_server.js
		2. Design it to handle different file types appropriately
		3. For codename_index: generate li elements for each line
		4. For start_file: generate div for each line with explicit indentation
		5. Calculate indent level from tabs (1 tab = 1 level)
		6. Add style="margin-left: Xpx" where X = level * 20
		7. Include full line text including numbers/letters
		8. Write complete HTML file with DOCTYPE, html, head, body tags
		9. For start_file: separate outline numbers (1., a., etc.) from text content
		10. Place outline numbers in separate span with fixed width to align wrapped text
		11. For codename_index: use CSS counters for automatic numbering instead of hardcoded numbers
		12. CSS counter implementation: ul { counter-reset: item }, li { counter-increment: item }
		13. CSS counter display: li::before { content: counter(item) ". " }
	b. Add file watching and initial generation
		1. Call txt_to_html_update on server startup for all files
		2. Add fs.watch for each file in file_config
		3. Call txt_to_html_update when any txt changes
		4. Log "Updated HTML from txt" on success
		5. Ensure each file updates independently

4. start_file_add
	a. Add 01_start to file config
		1. Add start_file entry to file_config in sync_server.js
		2. Set txt_path to 'prompt/01_start.txt'
		3. Set html_path to 'prompt/html/01_start.html'
		4. Verify both files sync independently
		5. URL routing: /01_start.html serves the generated HTML
		6. Ensure both codename_index and start_file are in file_config object
	b. Test multiple file handling
		1. Modify codename_index.txt and verify only codename_index.html updates
		2. Modify 01_start.txt and verify only 01_start.html updates
		3. Check console shows correct file being watched
		4. Confirm server handles both files on same port
	c. Verify HTML generation
		1. Ensure both HTML files are created on server startup
		2. Check codename_index.html contains li elements with codenames
		3. Check 01_start.html contains div elements with proper indentation
		4. Confirm both files are populated with content from txt files
		5. Verify left margin increases by consistent amount (20px) for each deeper indentation level
		6. Ensure tabs in source txt file map to indent levels (1 tab = 20px left margin)
		7. Verify outline numbers are in separate spans allowing text to wrap with aligned left edge

5. inline_edit_enable
	a. Add tap to edit for codename_index
		1. Add click event listener to li elements in generated HTML
		2. Make clicked element contenteditable="true" on click using setAttribute
		3. Add focus to element after making it editable with setTimeout for cursor placement
		4. Keep element editable when clicking outside - do NOT add blur event
		5. Add keydown event for Enter key to exit edit mode
		6. Remove contenteditable on Enter only using removeAttribute
		7. Add visual feedback with border during edit
		8. Use getAttribute to check if element is already editable
		9. Add cursor: pointer and hover effects for better UX
		10. Focus and place cursor at end of text when entering edit mode
		11. Element stays editable until Enter is pressed
		12. Use shared placeCursorAtClick function to place cursor at click position
	b. Add tap to edit for start_file
		1. Add click event listener to text spans (not outline numbers)
		2. Make only the text span contenteditable="true" on click using setAttribute
		3. Ensure outline numbers remain non-editable
		4. Only Enter key exits edit mode - no blur handler
		5. Preserve flex layout during editing
		6. Add visual feedback for active edit
		7. Use getAttribute/removeAttribute for proper contentEditable handling
		8. Apply cursor: pointer to editable text spans only
		9. Keep editable state when focus moves elsewhere
		10. Use same placeCursorAtClick function as codename_index for consistent behavior
	c. Note on sync behavior
		1. Edits will not yet propagate to txt files
		2. This is preparation for sync functionality

6. auto_reload
	a. Add modification tracking
		1. Add modification_times object to track file changes
		2. Initialize with current timestamps on server start
		3. Update timestamp when file watcher detects changes
		4. Store as milliseconds since epoch for easy comparison
	b. Add check endpoint
		1. Add GET /check/:filename route to sync_server.js
		2. Return JSON with last_modified timestamp
		3. Handle both codename_index and start_file requests
		4. Return 404 for unknown files
	c. Browser polling
		1. Add script to HTML generation for auto-reload
		2. Store initial timestamp on page load
		3. Poll /check endpoint every second
		4. Compare timestamps and reload if changed
		5. Use fetch API for polling requests
	d. Preserve edit state
		1. Add isEditing flag to track active edits
		2. Skip reload if isEditing is true
		3. Set isEditing to true when entering edit mode
		4. Set isEditing to false on Enter key only
		5. Ensure continuous editing without interruption
	e. Add CORS headers
		1. Add Access-Control-Allow-Origin: * to all responses
		2. Required for future sync functionality
		3. Enable cross-origin requests from browser

7. sync_foundation
	a. Create sync endpoint
		1. Add POST /sync route to sync_server.js
		2. Accept JSON body with file_name, line_number, text
		3. Log received sync data for verification
		4. Return success response
	b. Add CORS headers
		1. Add Access-Control-Allow-Origin: * to all responses
		2. Add OPTIONS method handling for preflight
		3. Test POST from browser console works
	c. Prepare for inline edit sync
		1. Endpoint will receive edits from inline editing
		2. Line numbers will come from data attributes
		3. Text will be the edited content

8. html_extract_module
	a. Create extraction module
		1. Create meta/browser2/html_extract.js
		2. Export extract_lines function that takes HTML string
		3. For codename_index: extract text from li elements
		4. For 01_start: extract text from div elements with indentation
		5. Preserve original formatting and spacing
		6. Handle inline edited content extraction
		7. Use regex to parse HTML elements and extract text content
		8. Calculate tab indentation from margin-left pixels (20px per tab)
		9. Handle both simple divs and divs with outline number spans
	b. Test extraction
		1. Import module in sync_server.js
		2. Add test endpoint /test-extract
		3. Verify it extracts lines correctly
		4. Remove test endpoint after verification

9. html_to_txt_sync
	a. Create sync function
		1. Add html_to_txt_write function in sync_server.js (implemented as sync_to_txt)
		2. Use html_extract to get lines from HTML (not needed - sync receives edited text directly)
		3. Update specific line in txt file array
		4. Write updated content back to txt file
		5. Handle empty line filtering for codename_index (map visible line to actual line)
		6. Preserve indentation for start_file (tabs and outline numbers)
		7. Set sync_in_progress flag to prevent reload loops
	b. Connect to sync endpoint
		1. Update /sync endpoint to call html_to_txt_write (calls sync_to_txt)
		2. Find correct file config based on file_name
		3. Update the txt file with new content
		4. Log "Synced to txt" on success
	c. Handle inline edits
		1. Receive edits from inline editing feature
		2. Update txt files with edited content
		3. Preserve formatting and indentation
		4. 

10. realtime_sync
	a. Add input event listeners
		1. Change from blur event to input event for real-time updates
		2. Debounce sync requests to avoid overwhelming server (e.g., 100ms delay)
		3. Send sync request on every keystroke after debounce
		4. Maintain cursor position during updates (TODO)
		5. Track current editing element and cursor position (TODO)
		6. Continue syncing even when element loses focus - no blur handler
		7. Only Enter key exits edit mode and stops syncing
	b. Implement cursor preservation (TODO)
		1. Before sync, save cursor position using Selection API
		2. After DOM update, restore cursor to correct position
		3. Handle edge cases like deleted text affecting cursor
		4. Account for text length changes from other sources
	c. Handle concurrent edits (TODO)
		1. Add version tracking to prevent overwrite conflicts
		2. Implement operational transformation basics
		3. If both sides edit simultaneously, merge changes intelligently
		4. Maintain edit state flags for both browser and txt sides
	d. Optimize performance
		1. Only sync the changed line, not entire file (implemented)
		2. Use WebSockets for lower latency (future enhancement)
		3. Batch rapid changes into single sync request (implemented via debounce)
		4. 

11. audit_architecture
	a. Review current architecture
		1. Verify sync_server.js supports multiple HTML files efficiently
		2. Check that file_config is scalable for adding new pages
		3. Ensure txt_to_html_update function is modular
		4. Confirm file watching works independently for each file
		5. Review shared code patterns across HTML generation
	b. Identify shared modules
		1. Common JavaScript for inline editing across all pages
		2. Shared CSS styles for consistent look and feel
		3. Debounce function used by all editable elements
		4. Auto-reload polling logic shared across pages
		5. Sync endpoint handling for all file types
	c. Verify extensibility
		1. Adding new files only requires file_config entry
		2. HTML generation follows consistent patterns
		3. Event handlers are attached dynamically
		4. No hardcoded file names in core logic

12. add_meta_index
	a. Create meta_index configuration
		1. Add meta_index entry to file_config in sync_server.js
		2. Set txt_path to 'meta/meta_index.txt'
		3. Set html_path to 'meta/html/meta_index.html'
		4. Use same li element generation as codename_index
	b. Create meta_index.txt file
		1. Create meta/meta_index.txt with initial codenames from meta folder
		2. Include identifiers used in sync_server.js and html_extract.js
		3. Format as simple list like codename_index.txt
		4. This will track codenames used in the meta-app itself
	c. Verify meta_index works
		1. Check that meta_index.html is generated on server start
		2. Verify inline editing works on meta_index
		3. Confirm sync back to meta_index.txt functions
		4. Test auto-reload on file changes
		5. Access via http://localhost:3002/meta_index.html

13. style_colors_setup
	a. Define Cursor.ai color scheme
		1. CSS variables: --bg: #1e1e1e, --text: #ffffff, --gray: #6e7681
		2. Additional: --hover: #2d2d2d, --edit-border: #007AFF
		3. Font: "SF Mono" and monospace fallbacks, size: 18px, line-height: 1.5
	b. Apply dark theme to codename_index
		1. Body background and text color
		2. Counter numbers (::before) use gray
		3. Hover and edit mode styling with defined colors
		4. Ensure hover regions touch with no gaps (padding: 2px 4px, margin: 0)
	c. Apply dark theme to start_file  
		1. Same body styling as codename_index
		2. Outline numbers in gray, content text in white
		3. Consistent hover and edit states
		4. Ensure hover regions touch with no gaps (margin-bottom: 0)
	d. Make edit mode seamless
		1. Remove border during edit mode - no visual difference
		2. Keep same background color when editing
		3. No green flash on sync - remove visual feedback
		4. Maintain exact same appearance in edit vs non-edit
		5. Only cursor position indicates edit mode

14. gray_duplicate_terms
	a. Apply gray coloring to duplicate term prefixes
		1. Modify txt_to_html_update for codename_index files
		2. Compare terms separated by underscores
		3. Split li into duplicate-part (gray) and unique-part (white) spans
		4. Store full text in data-fulltext for editing
		5. Handle tab-separated format in codename_index_1/2/3 files
	b. Edit behavior for split terms
		1. Click replaces split display with full text in white
		2. Click on different row exits previous edit mode
		3. Enter key exits edit mode and restores split display
		4. Edit state persists when switching windows
	c. Multiple codename files
		1. Add codename_index_1, _2, _3 to file_config
		2. Extract left column for display, preserve right column when syncing
		3. Apply same duplicate detection to all variants
	d. Navigation circles
		1. Green circles at bottom-right, 60px diameter
		2. Cycle between codename variants: main → 1 → 2 → 3 → main
		3. Stack vertically with 15px gap

15. outline_collapse_expand
	a. Add click handler to outline numbers
		1. Single click on outline number/letter toggles collapse/expand
		2. Store collapsed state in data attribute on parent div
		3. Hide/show all children at deeper indent levels
		4. No visual effects beyond content movement
		5. Cursor changes to pointer when hovering outline numbers
		6. Make outline numbers non-selectable with user-select: none
	b. Implement collapse logic
		1. Single click toggles visibility while preserving nested states
		2. When collapsing, hide all descendants regardless of their state
		3. When expanding, show immediate children and recursively show their descendants based on each element's collapsed state
		4. Use a stack-based approach to track which levels should be visible
		5. Elements maintain their own collapsed/expanded state even when hidden
	c. Add double-click handler
		1. Double-click expands/collapses all descendants recursively
		2. If any descendant is collapsed, expand all
		3. If all descendants expanded, collapse all
		4. Apply to all nested levels beneath clicked item
		5. Prevent text selection on double-click with preventDefault
	d. Visual feedback
		1. No animations or transitions
		2. Instant show/hide of content
		3. Outline number stays clickable in both states
		4. Text content remains editable when visible
	e. Standard click detection
		1. Use single click handler with 250ms delay timer
		2. If second click occurs within 250ms, cancel timer and treat as double-click
		3. Single click toggles immediate children only
		4. Double-click recursively expands/collapses all descendants
		5. No complex state tracking - simple and standard approach

16. green_control_buttons
	a. Add control buttons in top right
		1. Fixed position div with three green buttons
		2. Background color: #2ea043 (--green variable)
		3. White triangles and text, no borders
		4. Buttons have 8px 12px padding, 4px border-radius
		5. 10px gap between buttons
	b. Collapse All button (left)
		1. White triangle pointing up (▲)
		2. Clicking collapses all outline items at every level
		3. Sets data-collapsed="true" on all outline divs
		4. Updates all outline displays to show carets for items with children
		5. Hides all content except top-level items
	c. Expand to Level 2 button (middle)
		1. Contains white number "2"
		2. Opens all first-level items (shows their children)
		3. Closes all second-level items (hides their children)
		4. Leaves third-level and deeper items unchanged
		5. Only affects open/close state of first and second level items
	d. Expand All button (right)
		1. White triangle pointing down (▼)
		2. Clicking expands all outline items at every level
		3. Sets data-collapsed="false" on all outline divs
		4. Updates all outline displays to show periods
		5. Shows all content with proper flex/block display
	e. Default state on page load
		1. All top-level items start collapsed (data-collapsed="true")
		2. All other levels start expanded (data-collapsed="false")
		3. Only first-level content visible initially
		4. Users can expand to see deeper content
		5. Provides clean initial view of major sections

17. index_filter_buttons
	a. Add filter buttons to index.html
		1. Create fixed position div in top right with green buttons
		2. "Functions" button - toggles function item visibility
		3. "Files and Folders" button - toggles file/folder visibility
		4. Both default to "on" state, turn gray (#6e7681) when "off"
		5. Use data-type attributes on li elements: function, file, folder
	b. Implement index_filter_apply function
		1. Check index_filter_state object for button states
		2. Show/hide li elements based on data-type and filter state
		3. Call index_duplicate_update after filtering
		4. Ensure smooth visual transition

18. index_type_indicators
	a. Add visual type indicators
		1. Folders: append "/" in dark gray (#6e7681)
		2. Files: file extension in dark gray
		3. Functions: append "()" in dark gray
		4. Apply during li element generation in sync_server.js
	b. Detect item types
		1. Check for common folder names (app, meta, prompt, etc.)
		2. Check for dots to identify files with extensions
		3. Default to function if neither folder nor file

19. index_duplicate_dynamic
	a. Create index_duplicate_update function
		1. Recalculate gray/white coloring based on visible items only
		2. Skip hidden items when determining duplicates
		3. First visible occurrence always white
		4. Process only visible li elements in sequence
	b. Call after filter changes
		1. index_filter_apply calls index_duplicate_update
		2. Ensures correct coloring after filtering
		3. Maintains visual consistency

20. naming_convention_update
	a. Rename functions to component_action_verb pattern
		1. applyFilters → index_filter_apply
		2. filterState → index_filter_state  
		3. Add index_duplicate_update
		4. Update all references in code

21. outline_pixel_alignment
	a. Fix outline number alignment
		1. Add text-align: right to outline-number spans
		2. Ensures codenames line up regardless of outline width
		3. Maintains consistent visual hierarchy

22. folder_reorganization
	a. Move folders to new structure
		1. meta/tool → meta/src/tool
		2. meta/html/tool → meta/html/tool (no change)
		3. prompt → meta/src/prompt
		4. Create meta/layout for layout rules
		5. Create meta/code/layout and meta/code/sync
	b. Move files to appropriate folders
		1. Template and client files → meta/code/layout
		2. sync_server.js, meta.sh, html_extract.js → meta/code/sync
		3. Update all path references in code
	c. Split rules into specific files
		1. index_rule.txt → index_layout_rule.txt and codename_index_rule.txt
		2. Create web_rule.txt in meta/rule/tool

23. navigation_buttons
	a. Create nav_client.js
		1. Add four navigation buttons above filter buttons
		2. Index, Function, Web, Prompt buttons
		3. Active button shows blue (#007AFF), others gray
		4. Navigate between tool and prompt HTML pages
	b. Active state management
		1. Only one button active at a time
		2. Active button indicates current page
		3. Update active state based on current URL

24. filter_state_persistence
	a. Implement localStorage for filter buttons
		1. index_filter_save stores button states
		2. index_filter_load retrieves or uses defaults
		3. index_filter_update_buttons syncs appearance
		4. States persist across reloads and navigation

25. outline_state_persistence
	a. Add localStorage for collapse/expand states
		1. outline_state_save stores collapsed states by key
		2. outline_state_key_generate creates unique keys
		3. outline_state_restore loads saved states on page load
		4. Each page maintains separate collapse states

26. file_watcher_dynamic
	a. Remove hardcoded file entries
		1. Delete static entries from storage_file_config
		2. Create file_watcher_setup function
		3. Dynamically scan folders and set up watchers
		4. Fix 01_start.txt instant update issue

27. sync_server_cleanup
	a. Remove duplicate files
		1. Delete meta/tool/index.txt (use meta/src/tool)
		2. Delete meta/code/sync_server.js (use meta/code/sync)
		3. Update all references to correct paths
	b. Fix path references
		1. Update .cursor/rules for new structure
		2. Update prompt_rule.txt for sync server location
		3. Ensure all documentation reflects current structure

29. css_class_display
	a. Add CSS class indicators to index
		1. Show CSS classes used in each codename
		2. Display as comma-separated list ending with >
		3. Gray text (#6e7681) positioned after codename
		4. Classes shown: codename_part_duplicate, codename_part_unique
	b. CSS filter button
		1. Third button in filter controls
		2. Toggle CSS class visibility on/off
		3. Default to on state (green button, classes visible)
		4. State persists in localStorage
	c. Display format
		1. Example: field_mode_exit() codename_part_duplicate, codename_part_unique>
		2. Classes update dynamically with filtering
		3. Only show classes for items that use them
		4. Position with margin-left: 20px

/////////////////// YOU ARE HERE /////////////////////////////////

