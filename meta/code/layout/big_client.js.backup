// Big page client-side functionality
(function() {
    'use strict';
    
    // Add page visibility API to detect when page becomes visible
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            console.log('Page became visible, checking checkbox states...');
            const states = {
                functions: document.getElementById('toggle_functions')?.checked,
                methods: document.getElementById('toggle_methods')?.checked,
                data_create: document.getElementById('toggle_data_create')?.checked,
                data_ref: document.getElementById('toggle_data_ref')?.checked,
                dir: document.getElementById('toggle_dir')?.checked
            };
            console.log('Current checkbox states on visibility:', states);
        }
    });
    
    // Wait for DOM to be ready
    function init() {
        console.log('Big page initializing...');
        console.log('localStorage available:', typeof(Storage) !== 'undefined');
        console.log('Current localStorage contents:', {
            functions: localStorage.getItem('big_show_functions'),
            methods: localStorage.getItem('big_show_methods'),
            data_create: localStorage.getItem('big_show_data_create'),
            data_ref: localStorage.getItem('big_show_data_ref'),
            dir: localStorage.getItem('big_show_dir')
        });
        
        // Set up functions filter checkbox
        const toggle_functions = document.getElementById('toggle_functions');
        if (toggle_functions) {
            // Load saved state
            const saved_value = localStorage.getItem('big_show_functions');
            console.log('Loading functions checkbox state:', {
                saved_value: saved_value,
                will_be_checked: saved_value !== 'false',
                element_exists: toggle_functions !== null
            });
            const show_functions = saved_value !== 'false';
            toggle_functions.checked = show_functions;
            console.log('Functions checkbox checked property after setting:', toggle_functions.checked);
            // Don't update display yet - wait until all checkboxes are loaded
            
            toggle_functions.addEventListener('change', function() {
                const new_state = toggle_functions.checked;
                
                // If turning off functions, also turn off methods
                if (!new_state) {
                    const toggle_methods = document.getElementById('toggle_methods');
                    if (toggle_methods && toggle_methods.checked) {
                        toggle_methods.checked = false;
                        method_show_update(false);
                        localStorage.setItem('big_show_methods', 'false');
                    }
                }
                
                console.log('Functions checkbox changed:', {
                    new_state: new_state,
                    saving_as: String(new_state),
                    timestamp: new Date().toISOString()
                });
                localStorage.setItem('big_show_functions', String(new_state));
                console.log('Verified saved to localStorage:', localStorage.getItem('big_show_functions'));
                update_display();
            });
        }
        
        // Set up methods filter checkbox
        const toggle_methods = document.getElementById('toggle_methods');
        if (toggle_methods) {
            // Load saved state
            const show_methods = localStorage.getItem('big_show_methods') !== 'false';
            toggle_methods.checked = show_methods;
            // Don't update display yet - wait until all checkboxes are loaded
            
            toggle_methods.addEventListener('change', function() {
                const new_state = toggle_methods.checked;
                
                // If trying to turn on methods, ensure functions are on first
                if (new_state) {
                    const toggle_functions = document.getElementById('toggle_functions');
                    const functions_active = toggle_functions && toggle_functions.checked;
                    
                    if (!functions_active) {
                        // Turn on functions first
                        if (toggle_functions) {
                            toggle_functions.checked = true;
                            function_show_update(true);
                            localStorage.setItem('big_show_functions', 'true');
                        }
                    }
                }
                
                localStorage.setItem('big_show_methods', String(new_state));
                update_display();
            });
        }
        
        // Set up data structure creation filter checkbox
        const toggle_data_create = document.getElementById('toggle_data_create');
        if (toggle_data_create) {
            // Load saved state
            const show_data_create = localStorage.getItem('big_show_data_create') !== 'false';
            toggle_data_create.checked = show_data_create;
            // Don't update display yet - wait until all checkboxes are loaded
            
            toggle_data_create.addEventListener('change', function() {
                const new_state = toggle_data_create.checked;
                localStorage.setItem('big_show_data_create', String(new_state));
                update_display();
            });
        }
        
        // Set up data structure reference filter checkbox
        const toggle_data_ref = document.getElementById('toggle_data_ref');
        if (toggle_data_ref) {
            // Load saved state
            const show_data_ref = localStorage.getItem('big_show_data_ref') !== 'false';
            toggle_data_ref.checked = show_data_ref;
            // Don't update display yet - wait until all checkboxes are loaded
            
            toggle_data_ref.addEventListener('change', function() {
                const new_state = toggle_data_ref.checked;
                console.log('DATA_REF CHECKBOX CLICKED:', new_state);
                localStorage.setItem('big_show_data_ref', String(new_state));
                update_display();
            });
        }
        
        // Set up dir filter checkbox
        const toggle_dir = document.getElementById('toggle_dir');
        if (toggle_dir) {
            // Load saved state
            const show_dir = localStorage.getItem('big_show_dir') !== 'false';
            toggle_dir.checked = show_dir;
            // Don't update display yet - wait until all checkboxes are loaded
            
            toggle_dir.addEventListener('change', function() {
                const new_state = toggle_dir.checked;
                localStorage.setItem('big_show_dir', String(new_state));
                update_display();
            });
        }
        
        // Save state before page unloads (including auto-reload)
        window.addEventListener('beforeunload', function(e) {
            console.log('beforeunload event - saving state');
            state_all_save();
            // Log current state right before unload
            console.log('State saved on unload:', {
                functions: localStorage.getItem('big_show_functions'),
                methods: localStorage.getItem('big_show_methods'),
                data_create: localStorage.getItem('big_show_data_create'),
                data_ref: localStorage.getItem('big_show_data_ref'),
                dir: localStorage.getItem('big_show_dir')
            });
        });
        
        // Also save state periodically to catch any changes
        // But debounce it to avoid saving while user is typing
        let save_timer = null;
        function debounced_save() {
            if (save_timer) clearTimeout(save_timer);
            save_timer = setTimeout(state_all_save, 1000);
        }
        setInterval(debounced_save, 2000);
        
        // Remove the global click handler - let outline_client.js handle it
        // The outline_client.js script will manage all outline number clicks including double-click detection
        
        // Set up search functionality
        const search_input = document.getElementById('search_input');
        const search_clear = document.getElementById('search_clear');
        
        if (search_input) {
            search_input.addEventListener('input', function() {
                const raw_value = search_input.value;
                const search_term = raw_value.trim();
                
                if (raw_value) {
                    search_clear.classList.add('search_clear_visible');
                    if (search_term) {
                        search_big_apply(search_term.toLowerCase());
                    } else {
                        // Just spaces - clear the search results
                        search_big_clear();
                    }
                } else {
                    search_clear.classList.remove('search_clear_visible');
                    search_big_clear();
                }
            });
            
            // Clear button
            if (search_clear) {
                search_clear.addEventListener('click', function() {
                    search_input.value = '';
                    search_clear.classList.remove('search_clear_visible');
                    search_big_clear();
                    search_input.focus();
                });
            }
        }
        
        // Add a small delay to ensure DOM is fully ready
        console.log('Waiting 100ms before initial setup...');
        setTimeout(() => {
            console.log('Running delayed initialization');
            
            // Load saved states after all event handlers are set up
            state_all_load();
            
            // Now update display after all checkboxes are loaded
            update_display();
            
            // Log final checkbox states after initialization
            console.log('Final checkbox states after init:', {
                functions: document.getElementById('toggle_functions')?.checked,
                methods: document.getElementById('toggle_methods')?.checked,
                data_create: document.getElementById('toggle_data_create')?.checked,
                data_ref: document.getElementById('toggle_data_ref')?.checked,
                dir: document.getElementById('toggle_dir')?.checked
            });
        }, 100);
        
        // Apply initial duplicate detection
        big_duplicate_update();
        
        // Set up time filter
        const time_filter_select = document.getElementById('time_filter_select');
        if (time_filter_select) {
            // Load saved time filter state
            const saved_time_filter = localStorage.getItem('big_time_filter') || '0';
            time_filter_select.value = saved_time_filter;
            
            time_filter_select.addEventListener('change', function() {
                const filter_value = time_filter_select.value;
                localStorage.setItem('big_time_filter', filter_value);
                time_filter_big_apply(parseInt(filter_value));
            });
            
            // Apply initial time filter
            time_filter_big_apply(parseInt(saved_time_filter));
        }
    }
    
    function descendant_toggle(parent_div, show) {
        const parent_indent = parseInt(parent_div.getAttribute('data-indent') || '0');
        let sibling = parent_div.nextElementSibling;
        
        while (sibling && sibling.getAttribute('data-indent')) {
            const sibling_indent = parseInt(sibling.getAttribute('data-indent'));
            
            if (sibling_indent <= parent_indent) {
                break; // Reached same or higher level
            }
            
            if (sibling_indent === parent_indent + 1) {
                // Direct child
                // Don't show if it's hidden by filter
                if ((sibling.classList.contains('method_calls') && sibling.classList.contains('hidden')) ||
                    (sibling.classList.contains('function_line') && sibling.classList.contains('hidden'))) {
                    // Skip showing this one, but still process its children if hiding
                    if (!show) {
                        descendant_toggle(sibling, false);
                    }
                } else {
                    sibling.style.display = show ? 'flex' : 'none';
                    
                    // If hiding, also hide its children
                    if (!show) {
                        descendant_toggle(sibling, false);
                    } else if (sibling.getAttribute('data-collapsed') !== 'true') {
                        // If showing and child is expanded, show its children too
                        descendant_toggle(sibling, true);
                    }
                }
            } else {
                // Deeper descendant - only show if parent chain is expanded
                if ((sibling.classList.contains('method_calls') && sibling.classList.contains('hidden')) ||
                    (sibling.classList.contains('function_line') && sibling.classList.contains('hidden'))) {
                    // Skip showing this one
                } else {
                    sibling.style.display = show ? 'flex' : 'none';
                }
            }
            
            sibling = sibling.nextElementSibling;
        }
    }
    
    function state_all_save() {
        console.log('state_all_save called at:', new Date().toISOString());
        
        // First save checkbox states explicitly
        const checkboxes = ['toggle_functions', 'toggle_methods', 'toggle_data_create', 'toggle_data_ref', 'toggle_dir'];
        checkboxes.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                const key = id.replace('toggle_', 'big_show_');
                const value = String(checkbox.checked);
                console.log(`Saving ${key} = ${value}`);
                localStorage.setItem(key, value);
            }
        });
        
        const state = {
            collapsed: {},
            search: '',
            cursor_position: null,
            cursor_active: false
        };
        
        // Save collapsed state
        const all_divs = document.querySelectorAll('div[data-indent]');
        all_divs.forEach((div, index) => {
            const collapsed = div.getAttribute('data-collapsed') === 'true';
            const indent = div.getAttribute('data-indent');
            const text = div.textContent.trim().replace(/\s+/g, ' ').substring(0, 50);
            
            // Create a more robust key that can survive page reloads
            const key = `${indent}_${text}`;
            if (collapsed) {
                state.collapsed[key] = true;
            }
        });
        
        // Save search term and cursor position
        const search_input = document.getElementById('search_input');
        if (search_input) {
            state.search = search_input.value;
            state.cursor_position = search_input.selectionStart;
            state.cursor_active = document.activeElement === search_input;
        }
        
        console.log('Saving outline state:', Object.keys(state.collapsed).length, 'collapsed items, search:', state.search, 'cursor:', state.cursor_position);
        try {
            localStorage.setItem('big_outline_state', JSON.stringify(state));
            console.log('All state saved successfully');
        } catch (e) {
            console.error('Failed to save state:', e);
        }
    }
    
    function state_all_load() {
        const saved = localStorage.getItem('big_outline_state');
        if (!saved) {
            // Default state: everything is open, so nothing to do
            return;
        }
        
        try {
            const state = JSON.parse(saved);
            
            // Handle both old format (direct object) and new format (with collapsed/search)
            let collapsed_state = state.collapsed || state;
            let search_term = state.search || '';
            let cursor_position = state.cursor_position;
            let cursor_active = state.cursor_active;
            
            console.log('Loading state:', Object.keys(collapsed_state).length, 'collapsed items, search:', search_term, 'cursor:', cursor_position);
            
            // Restore search term
            const search_input = document.getElementById('search_input');
            console.log('Restoring search:', { 
                element_exists: !!search_input, 
                saved_search: search_term,
                current_value: search_input?.value 
            });
            if (search_input && search_term) {
                search_input.value = search_term;
                console.log('Set search value to:', search_input.value);
                // Delay the input event to ensure it's processed correctly
                setTimeout(() => {
                    search_input.dispatchEvent(new Event('input'));
                    console.log('Dispatched input event for search');
                }, 50);
                
                // Restore cursor position and focus if it was active
                if (cursor_active) {
                    search_input.focus();
                    if (cursor_position !== null && cursor_position !== undefined) {
                        search_input.setSelectionRange(cursor_position, cursor_position);
                    }
                }
            }
            
            // Restore collapsed state
            const all_divs = document.querySelectorAll('div[data-indent]');
            
            all_divs.forEach((div, index) => {
                const indent = div.getAttribute('data-indent');
                const text = div.textContent.trim().replace(/\s+/g, ' ').substring(0, 50);
                const key = `${indent}_${text}`;
                
                if (collapsed_state[key]) {
                    // This item should be collapsed
                    div.setAttribute('data-collapsed', 'true');
                    
                    const outline_num = div.querySelector('.outline_line_number');
                    if (outline_num) {
                        const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                        outline_num.textContent = original.replace('.', '>');
                    }
                    
                    descendant_toggle(div, false);
                }
            });
        } catch (e) {
            console.error('Failed to load state:', e);
        }
    }
    
    function function_show_update(show) {
        const function_lines = document.querySelectorAll('.function_line');
        console.log('function_show_update called:', { show, function_lines_count: function_lines.length });
        const show_data_create = document.getElementById('toggle_data_create')?.checked || false;
        const show_data_ref = document.getElementById('toggle_data_ref')?.checked || false;
        const data_filters_active = show_data_create || show_data_ref;
        
        function_lines.forEach(func => {
            const has_data_create = func.getAttribute('data-has-data-create') === 'true';
            const has_data_ref = func.getAttribute('data-has-data-ref') === 'true';
            
            // Determine if this function should be shown
            let should_show = false;
            
            if (show) {
                // Function filter is on - show all functions
                should_show = true;
            } else if (!show && data_filters_active) {
                // Function filter is off, check if this function has the specific type of data being filtered
                if (show_data_create && has_data_create) {
                    // Data create filter is on and this function has data creation
                    should_show = true;
                } else if (show_data_ref && has_data_ref) {
                    // Data ref filter is on and this function has data references
                    should_show = true;
                }
            }
            
            if (should_show) {
                func.classList.remove('hidden');
                func.style.display = 'flex';
                // Also check if its children should be visible
                const is_collapsed = func.getAttribute('data-collapsed') === 'true';
                if (!is_collapsed) {
                    descendant_toggle(func, true);
                }
            } else {
                func.classList.add('hidden');
                func.style.display = 'none';
                // Hide all children when hiding functions
                descendant_toggle(func, false);
            }
        });
        
        const toggle_button = document.getElementById('toggle_functions');
        if (toggle_button) {
            if (show) {
                toggle_button.classList.add('active');
            } else {
                toggle_button.classList.remove('active');
            }
        }
        
        // Update duplicate detection after function visibility changes
        big_duplicate_update();
        
        // Update file visibility
        file_visibility_update();
    }
    
    function method_show_update(show) {
        const method_calls = document.querySelectorAll('.method_calls');
        console.log('method_show_update called:', { show, method_calls_count: method_calls.length });
        method_calls.forEach(method => {
            if (show) {
                method.classList.remove('hidden');
                method.style.display = 'flex';
            } else {
                method.classList.add('hidden');
                method.style.display = 'none';
            }
        });
        
        const toggle_button = document.getElementById('toggle_methods');
        if (toggle_button) {
            if (show) {
                toggle_button.classList.add('active');
            } else {
                toggle_button.classList.remove('active');
            }
        }
        
        // Update duplicate detection after method visibility changes
        big_duplicate_update();
        
        // Update file visibility
        file_visibility_update();
    }
    
    function data_create_show_update(show) {
        const data_create_lines = document.querySelectorAll('.data_create_line');
        console.log('data_create_show_update called:', { show, data_create_lines_count: data_create_lines.length });
        data_create_lines.forEach(line => {
            if (show) {
                line.classList.remove('data_create_hidden');
                line.style.display = 'flex';
            } else {
                line.classList.add('data_create_hidden');
                line.style.display = 'none';
            }
        });
        
        const toggle_button = document.getElementById('toggle_data_create');
        if (toggle_button) {
            if (show) {
                toggle_button.classList.add('active');
            } else {
                toggle_button.classList.remove('active');
            }
        }
        
        // Update duplicate detection after data structure visibility changes
        big_duplicate_update();
        
        // Update file visibility
        file_visibility_update();
    }
    
    function data_ref_show_update(show) {
        const data_ref_lines = document.querySelectorAll('.data_ref_line');
        console.log('DATA_REF_SHOW_UPDATE CALLED:', { show, data_ref_lines_count: data_ref_lines.length });
        
        // Also check for any elements with the class
        const all_data_refs = document.querySelectorAll('[class*="data_ref"]');
        console.log('All elements with data_ref in class:', all_data_refs.length);
        data_ref_lines.forEach(line => {
            if (show) {
                line.classList.remove('data_ref_hidden');
                line.style.display = 'flex';
            } else {
                line.classList.add('data_ref_hidden');
                line.style.display = 'none';
            }
        });
        
        const toggle_button = document.getElementById('toggle_data_ref');
        if (toggle_button) {
            if (show) {
                toggle_button.classList.add('active');
            } else {
                toggle_button.classList.remove('active');
            }
        }
        
        // Update duplicate detection after data structure visibility changes
        big_duplicate_update();
        
        // Update file visibility
        file_visibility_update();
    }
    
    function dir_show_update(show) {
        const content = document.getElementById('content');
        if (!content) return;
        
        // Get current filter states
        const show_functions = document.getElementById('toggle_functions')?.checked || false;
        const show_methods = document.getElementById('toggle_methods')?.checked || false;
        const show_data_create = document.getElementById('toggle_data_create')?.checked || false;
        const show_data_ref = document.getElementById('toggle_data_ref')?.checked || false;
        
        // Check if all filters are on or all are off
        const all_on = show_functions && show_methods && show_data_create && show_data_ref;
        const all_off = !show_functions && !show_methods && !show_data_create && !show_data_ref;
        const show_all_dirs = all_on || all_off;
        
        if (show) {
            // Dir checkbox is checked - show directory structure based on what's needed
            const all_divs = content.querySelectorAll('div[data-indent]');
            
            // First, restore original margins, outline numbers, and hidden elements
            all_divs.forEach(div => {
                const indent = parseInt(div.getAttribute('data-indent') || '0');
                div.style.marginLeft = (indent * 60) + 'px';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num && outline_num.getAttribute('data-original')) {
                    outline_num.textContent = outline_num.getAttribute('data-original');
                }
                
                // Restore visibility of all child elements (parentheses, line numbers, etc.)
                const all_children = div.querySelectorAll('*');
                all_children.forEach(child => {
                    if (child.style.display === 'none' && 
                        (child.classList.contains('big_function_paren') || 
                         child.style.color === 'var(--gray)')) {
                        child.style.display = '';
                    }
                });
            });
            
            if (show_all_dirs) {
                // Show all folders and files, then apply filters
                all_divs.forEach(div => {
                    div.style.display = 'flex';
                });
                
                // Apply individual filters
                function_show_update(show_functions);
                method_show_update(show_methods);
                data_create_show_update(show_data_create);
                data_ref_show_update(show_data_ref);
            } else {
                // Show only folders/files that contain visible items
                const visible_items = new Set();
                
                // Find all items that should be visible based on filters
                all_divs.forEach(div => {
                    const has_function = div.querySelector('.big_function_def_name');
                    const has_method = div.querySelector('.big_function_call_name');
                    const has_data_create = div.querySelector('.big_data_create');
                    const has_data_ref = div.querySelector('.big_data_ref');
                    
                    let should_show = false;
                    if (has_function && show_functions) should_show = true;
                    if (has_method && show_methods) should_show = true;
                    if (has_data_create && show_data_create) should_show = true;
                    if (has_data_ref && show_data_ref) should_show = true;
                    
                    if (should_show) {
                        visible_items.add(div);
                        // Add all ancestors (folders/files) to visible set
                        let current = div;
                        const current_indent = parseInt(current.getAttribute('data-indent') || '0');
                        
                        // Find all ancestors by checking previous siblings with lower indent
                        let prev = current.previousElementSibling;
                        while (prev) {
                            if (prev.getAttribute('data-indent')) {
                                const prev_indent = parseInt(prev.getAttribute('data-indent'));
                                if (prev_indent < current_indent) {
                                    visible_items.add(prev);
                                    current = prev;
                                }
                            }
                            prev = prev.previousElementSibling;
                        }
                    }
                });
                
                // Show/hide based on visibility
                all_divs.forEach(div => {
                    const has_folder = div.querySelector('.big_folder_name');
                    const has_file = div.querySelector('.big_file_name');
                    const has_function = div.querySelector('.big_function_def_name');
                    const has_method = div.querySelector('.big_function_call_name');
                    const has_data_create = div.querySelector('.big_data_create');
                    const has_data_ref = div.querySelector('.big_data_ref');
                    
                    if (has_folder || has_file) {
                        // Show folder/file only if it has visible children
                        if (visible_items.has(div)) {
                            div.style.display = 'flex';
                        } else {
                            div.style.display = 'none';
                        }
                    } else {
                        // For functions/methods/data, show based on filter state
                        let should_show = false;
                        if (has_function && show_functions && visible_items.has(div)) should_show = true;
                        if (has_method && show_methods && visible_items.has(div)) should_show = true;
                        if (has_data_create && show_data_create && visible_items.has(div)) should_show = true;
                        if (has_data_ref && show_data_ref && visible_items.has(div)) should_show = true;
                        
                        div.style.display = should_show ? 'flex' : 'none';
                    }
                });
            }
            
            // Update file visibility
            file_visibility_update();
            
            // Run normal duplicate detection
            big_duplicate_update();
        } else {
            // Hide ALL folders and files, show only functions/methods/data in flat list
            const all_items = [];
            // Track seen items by type to prevent duplicates within the same type
            const seen_by_type = {
                'function': new Set(),
                'method': new Set(),
                'data_create': new Set(),
                'data_ref': new Set()
            };
            
            // First hide all divs
            const all_divs = content.querySelectorAll('div[data-indent]');
            all_divs.forEach(div => {
                div.style.display = 'none';
            });
            
            // Collect visible functions/methods/data based on current filters
            const show_functions = document.getElementById('toggle_functions')?.checked || false;
            const show_methods = document.getElementById('toggle_methods')?.checked || false;
            const show_data_create = document.getElementById('toggle_data_create')?.checked || false;
            const show_data_ref = document.getElementById('toggle_data_ref')?.checked || false;
            
            all_divs.forEach(div => {
                const has_folder = div.querySelector('.big_folder_name');
                const has_file = div.querySelector('.big_file_name');
                const has_function = div.querySelector('.big_function_def_name');
                const has_method = div.querySelector('.big_function_call_name');
                const has_data_create = div.querySelector('.big_data_create');
                const has_data_ref = div.querySelector('.big_data_ref');
                
                // Skip folders and files entirely
                if (has_folder || has_file) {
                    return;
                }
                
                // Check if this item should be shown based on filters
                let should_show = false;
                let text = '';
                let item_type = '';
                
                if (has_function && show_functions) {
                    text = has_function.textContent.trim();
                    item_type = 'function';
                    if (!seen_by_type.function.has(text)) {
                        seen_by_type.function.add(text);
                        should_show = true;
                    }
                } else if (has_method && show_methods) {
                    text = has_method.textContent.trim();
                    item_type = 'method';
                    if (!seen_by_type.method.has(text)) {
                        seen_by_type.method.add(text);
                        should_show = true;
                    }
                } else if (has_data_create && show_data_create) {
                    text = has_data_create.textContent.trim();
                    item_type = 'data_create';
                    if (!seen_by_type.data_create.has(text)) {
                        seen_by_type.data_create.add(text);
                        should_show = true;
                    }
                } else if (has_data_ref && show_data_ref) {
                    text = has_data_ref.textContent.trim();
                    item_type = 'data_ref';
                    if (!seen_by_type.data_ref.has(text)) {
                        seen_by_type.data_ref.add(text);
                        should_show = true;
                    }
                }
                
                if (should_show && text) {
                    all_items.push({div: div, text: text, type: item_type});
                }
            });
            
            // Sort alphabetically
            all_items.sort((a, b) => a.text.localeCompare(b.text));
            
            // Show sorted items with proper alignment and apply duplicate term styling
            let previousTerms = [];
            
            // Calculate the width needed for the largest number
            const total_items = all_items.length;
            const max_digits = total_items.toString().length;
            const number_width = Math.max(45, (max_digits + 1) * 10 + 15); // +1 for dot, extra space for padding
            
            all_items.forEach((item, index) => {
                item.div.style.display = 'flex';
                item.div.style.marginLeft = '0px';
                // Update outline numbers sequentially with consistent width
                const outline_num = item.div.querySelector('.outline_line_number');
                if (outline_num) {
                    outline_num.textContent = (index + 1) + '.';
                    outline_num.style.width = number_width + 'px';
                }
                
                // Hide symbols and line numbers in flat view
                const text_span = item.div.querySelector('.list_edit_text');
                if (text_span) {
                    // Find the main element (function name or data structure name)
                    const main_element = text_span.querySelector('.big_function_def_name') ||
                                       text_span.querySelector('.big_function_call_name') ||
                                       text_span.querySelector('.big_data_create') ||
                                       text_span.querySelector('.big_data_ref');
                    
                    if (main_element && main_element.nextSibling) {
                        // Hide everything after the main element (parentheses, braces, arrows, line numbers)
                        let sibling = main_element.nextSibling;
                        while (sibling) {
                            if (sibling.nodeType === Node.ELEMENT_NODE) {
                                sibling.style.display = 'none';
                            } else if (sibling.nodeType === Node.TEXT_NODE) {
                                // Hide text nodes that contain symbols
                                const text = sibling.textContent;
                                if (text.includes('{') || text.includes('->') || text.includes('(')) {
                                    sibling.textContent = '';
                                }
                            }
                            sibling = sibling.nextSibling;
                        }
                    }
                }
                
                // Apply duplicate term styling
                const text_span = item.div.querySelector('.list_edit_text');
                if (text_span) {
                    const target_element = text_span.querySelector('.big_function_def_name') ||
                                         text_span.querySelector('.big_function_call_name') ||
                                         text_span.querySelector('.big_data_create') ||
                                         text_span.querySelector('.big_data_ref');
                    
                    if (target_element) {
                        const current_text = target_element.textContent;
                        const current_terms = current_text.split('_');
                        
                        // Clear any existing duplicate styling
                        target_element.innerHTML = current_text;
                        
                        // Apply duplicate styling based on previous item
                        if (previousTerms.length > 0) {
                            let html = '';
                            let duplicate_count = 0;
                            
                            // Compare with previous terms
                            for (let i = 0; i < current_terms.length; i++) {
                                if (i < previousTerms.length && current_terms[i] === previousTerms[i]) {
                                    duplicate_count++;
                                } else {
                                    break;
                                }
                            }
                            
                            // Build HTML with duplicate styling
                            if (duplicate_count > 0) {
                                const duplicate_part = current_terms.slice(0, duplicate_count).join('_');
                                const unique_part = current_terms.slice(duplicate_count).join('_');
                                
                                html = `<span class="big_term_duplicate">${duplicate_part}</span>`;
                                if (unique_part) {
                                    html += `<span class="big_term_duplicate">_</span>${unique_part}`;
                                } else if (duplicate_count < current_terms.length) {
                                    html += '_';
                                }
                            } else {
                                html = current_text;
                            }
                            
                            target_element.innerHTML = html;
                        }
                        
                        previousTerms = current_terms;
                    }
                }
            });
        }
    }
    
    // Comprehensive display update function
    function update_display() {
        console.log('update_display called at:', new Date().toISOString());
        
        // First, ensure all individual visibility states are applied
        const show_functions = document.getElementById('toggle_functions')?.checked || false;
        const show_methods = document.getElementById('toggle_methods')?.checked || false;
        const show_data_create = document.getElementById('toggle_data_create')?.checked || false;
        const show_data_ref = document.getElementById('toggle_data_ref')?.checked || false;
        
        console.log('Current checkbox states in update_display:', {
            show_functions,
            show_methods,
            show_data_create,
            show_data_ref,
            show_dir: document.getElementById('toggle_dir')?.checked
        });
        
        // Apply individual visibility updates
        function_show_update(show_functions);
        method_show_update(show_methods);
        data_create_show_update(show_data_create);
        data_ref_show_update(show_data_ref);
        
        // Then handle directory display
        const show_dir = document.getElementById('toggle_dir')?.checked !== false;
        
        if (show_dir) {
            // When dir is checked, update based on directory structure
            dir_show_update(true);
        } else {
            // When dir is unchecked, show flat list
            dir_show_update(false);
        }
    }
    
    function search_big_apply(search_term) {
        const all_divs = document.querySelectorAll('div[data-indent]');
        const matched_paths = new Set();
        
        // First pass: find all matching items
        all_divs.forEach(div => {
            const text_content = div.textContent.toLowerCase();
            const is_match = text_content.includes(search_term);
            
            if (is_match) {
                // Mark this item and all its ancestors as needing to be shown
                let current = div;
                while (current && current.getAttribute('data-indent')) {
                    matched_paths.add(current);
                    
                    // Find parent by going backwards through siblings
                    const current_indent = parseInt(current.getAttribute('data-indent'));
                    let prev = current.previousElementSibling;
                    
                    while (prev) {
                        if (prev.getAttribute('data-indent')) {
                            const prev_indent = parseInt(prev.getAttribute('data-indent'));
                            if (prev_indent < current_indent) {
                                current = prev;
                                break;
                            }
                        }
                        prev = prev.previousElementSibling;
                    }
                    
                    if (prev === null) break;
                }
            }
        });
        
        // Second pass: hide/show based on matches
        all_divs.forEach(div => {
            if (matched_paths.has(div)) {
                div.classList.remove('search_hidden');
                
                // If it's a match and not just an ancestor, expand it
                const text_content = div.textContent.toLowerCase();
                if (text_content.includes(search_term)) {
                    // Expand this item to show its children
                    div.setAttribute('data-collapsed', 'false');
                    const outline_num = div.querySelector('.outline_line_number');
                    if (outline_num) {
                        const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                        outline_num.textContent = original.replace('>', '.');
                    }
                }
            } else {
                div.classList.add('search_hidden');
            }
        });
        
        // Show all children of matched items
        matched_paths.forEach(div => {
            if (div.getAttribute('data-collapsed') !== 'true') {
                descendant_toggle(div, true);
            }
        });
        
        // Update duplicate detection after search
        big_duplicate_update();
    }
    
    function search_big_clear() {
        const all_divs = document.querySelectorAll('div[data-indent]');
        
        all_divs.forEach(div => {
            div.classList.remove('search_hidden');
        });
        
        // Restore only collapse states, not search
        const saved = localStorage.getItem('big_outline_state');
        if (saved) {
            try {
                const state = JSON.parse(saved);
                const collapsed_state = state.collapsed || state;
                
                // Restore collapsed state
                const all_divs = document.querySelectorAll('div[data-indent]');
                
                all_divs.forEach((div, index) => {
                    const indent = div.getAttribute('data-indent');
                    const text = div.textContent.trim().replace(/\s+/g, ' ').substring(0, 50);
                    const key = `${indent}_${text}`;
                    
                    if (collapsed_state[key]) {
                        // This item should be collapsed
                        div.setAttribute('data-collapsed', 'true');
                        
                        const outline_num = div.querySelector('.outline_line_number');
                        if (outline_num) {
                            const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                            outline_num.textContent = original.replace('.', '>');
                        }
                        
                        descendant_toggle(div, false);
                    }
                });
            } catch (e) {
                console.error('Failed to restore collapse states:', e);
            }
        }
        
        // Update duplicate detection after clearing search
        big_duplicate_update();
        
        // Reapply dir filter state
        const show_dir = document.getElementById('toggle_dir')?.checked !== false;
        dir_show_update(show_dir);
    }
    
    function file_visibility_update() {
        // Check each file to see if it has any visible content
        const all_divs = document.querySelectorAll('div[data-indent]');
        const files = [];
        
        // First, identify all file divs (they have data-modified attribute)
        all_divs.forEach(div => {
            if (div.getAttribute('data-modified')) {
                files.push(div);
            }
        });
        
        // For each file, check if it has any visible children
        files.forEach(file => {
            const file_indent = parseInt(file.getAttribute('data-indent') || '0');
            let has_visible_content = false;
            let next = file.nextElementSibling;
            
            // Check all children of this file
            while (next && parseInt(next.getAttribute('data-indent') || '0') > file_indent) {
                // Check if this child is visible
                // For data structures, check if they're actually visible
                const is_data_create = next.classList.contains('data_create_line');
                const is_data_ref = next.classList.contains('data_ref_line');
                const is_function = next.classList.contains('function_line');
                const is_method = next.classList.contains('method_calls');
                
                let is_visible = false;
                
                if (is_data_create && !next.classList.contains('data_create_hidden')) {
                    is_visible = true;
                } else if (is_data_ref && !next.classList.contains('data_ref_hidden')) {
                    is_visible = true;
                } else if (is_function && !next.classList.contains('hidden')) {
                    is_visible = true;
                } else if (is_method && !next.classList.contains('hidden')) {
                    is_visible = true;
                } else if (!is_data_create && !is_data_ref && !is_function && !is_method) {
                    // Other content (like module-level items) - check general visibility
                    is_visible = next.style.display !== 'none' && 
                                !next.classList.contains('search_hidden') &&
                                !next.classList.contains('time_hidden');
                }
                
                if (is_visible) {
                    has_visible_content = true;
                    break;
                }
                next = next.nextElementSibling;
            }
            
            // Hide/show the file based on whether it has visible content
            if (!has_visible_content) {
                file.classList.add('empty_file_hidden');
                file.style.display = 'none';
            } else {
                file.classList.remove('empty_file_hidden');
                if (!file.classList.contains('search_hidden') && 
                    !file.classList.contains('time_hidden')) {
                    file.style.display = 'flex';
                }
            }
        });
        
        // Also update folder visibility - hide folders with no visible files
        const folders = [];
        all_divs.forEach(div => {
            // Folders don't have data-modified and contain folder names
            if (!div.getAttribute('data-modified') && 
                div.querySelector('.big_folder_name')) {
                folders.push(div);
            }
        });
        
        folders.forEach(folder => {
            const folder_indent = parseInt(folder.getAttribute('data-indent') || '0');
            let has_visible_content = false;
            let next = folder.nextElementSibling;
            
            // Check all children of this folder
            while (next && parseInt(next.getAttribute('data-indent') || '0') > folder_indent) {
                if (next.style.display !== 'none' && 
                    !next.classList.contains('empty_file_hidden')) {
                    has_visible_content = true;
                    break;
                }
                next = next.nextElementSibling;
            }
            
            // Hide/show the folder
            if (!has_visible_content) {
                folder.style.display = 'none';
            } else if (!folder.classList.contains('search_hidden') && 
                       !folder.classList.contains('time_hidden')) {
                folder.style.display = 'flex';
            }
        });
    }
    
    function big_duplicate_update() {
        // Clear existing duplicate styling
        const all_duplicates = document.querySelectorAll('.big_term_duplicate');
        all_duplicates.forEach(span => {
            const parent = span.parentNode;
            if (parent) {
                parent.innerHTML = parent.textContent; // Remove HTML tags
            }
        });
        
        // Get all visible div elements with data-indent
        const all_divs = document.querySelectorAll('div[data-indent]');
        const visible_divs = Array.from(all_divs).filter(div => {
            return div.style.display !== 'none' && 
                   !div.classList.contains('search_hidden') && 
                   !div.classList.contains('time_hidden') &&
                   !div.classList.contains('hidden') && // Also filter out elements hidden by function/method toggles
                   !div.classList.contains('data_create_hidden') &&
                   !div.classList.contains('data_ref_hidden');
        });
        
        // Track terms we've seen to ensure only subsequent instances get grayed
        const seen_terms = new Map(); // term -> first occurrence index
        
        // Apply duplicate detection to adjacent visible items at the same level
        for (let i = 1; i < visible_divs.length; i++) {
            const current_div = visible_divs[i];
            const prev_div = visible_divs[i - 1];
            
            // Get indent levels to check if they're at the same hierarchical level
            const current_indent = parseInt(current_div.getAttribute('data-indent') || '0');
            const prev_indent = parseInt(prev_div.getAttribute('data-indent') || '0');
            
            // Only apply duplicate detection if items are at the same indent level
            if (current_indent === prev_indent) {
                const current_text = big_extract_text_content(current_div);
                const prev_text = big_extract_text_content(prev_div);
                
                if (current_text && prev_text) {
                    big_apply_duplicate_styling(current_div, current_text, prev_text);
                }
            }
        }
    }
    
    function big_extract_text_content(div) {
        // Extract the main text content (folder name, file name, function name, etc.)
        const text_span = div.querySelector('.list_edit_text');
        if (!text_span) return null;
        
        // Get text from different types of elements
        const folder_name = text_span.querySelector('.big_folder_name');
        const file_name = text_span.querySelector('.big_file_name');
        const function_def_name = text_span.querySelector('.big_function_def_name');
        const function_call_name = text_span.querySelector('.big_function_call_name');
        const data_create = text_span.querySelector('.big_data_create');
        const data_ref = text_span.querySelector('.big_data_ref');
        
        if (folder_name) return folder_name.textContent;
        if (file_name) return file_name.textContent;
        if (function_def_name) return function_def_name.textContent;
        if (function_call_name) return function_call_name.textContent;
        if (data_create) return data_create.textContent.replace(' {}', '');
        if (data_ref) return data_ref.textContent.replace(' ->', '');
        
        return null;
    }
    
    function big_apply_duplicate_styling(current_div, current_text, prev_text) {
        const delimiters = /[_\-\.\s]+/;
        const current_parts = current_text.split(delimiters);
        const prev_parts = prev_text.split(delimiters);
        
        // Find how many consecutive terms match from the beginning
        let matching_terms = 0;
        const min_length = Math.min(current_parts.length, prev_parts.length);
        
        for (let i = 0; i < min_length; i++) {
            if (current_parts[i] === prev_parts[i]) {
                matching_terms++;
            } else {
                break;
            }
        }
        
        // Only apply styling if we have matches and there are remaining unique parts
        if (matching_terms > 0 && matching_terms < current_parts.length) {
            // Find the character position where unique part starts
            let duplicate_end_pos = 0;
            for (let i = 0; i < matching_terms; i++) {
                duplicate_end_pos += current_parts[i].length;
                // Add delimiter length if not the last matching term
                if (i < matching_terms - 1 || matching_terms < current_parts.length) {
                    const remaining_text = current_text.substring(duplicate_end_pos);
                    const delim_match = remaining_text.match(/^[_\-\.\s]+/);
                    if (delim_match) {
                        duplicate_end_pos += delim_match[0].length;
                    }
                }
            }
            
            const duplicate_part = current_text.substring(0, duplicate_end_pos);
            const unique_part = current_text.substring(duplicate_end_pos);
            
            // Apply styling to the appropriate element
            const text_span = current_div.querySelector('.list_edit_text');
            if (text_span) {
                const target_element = text_span.querySelector('.big_folder_name') ||
                                     text_span.querySelector('.big_file_name') ||
                                     text_span.querySelector('.big_function_def_name') ||
                                     text_span.querySelector('.big_function_call_name');
                
                if (target_element) {
                    target_element.innerHTML = `<span class="big_term_duplicate">${duplicate_part}</span>${unique_part}`;
                }
            }
        }
    }
    
    function time_filter_big_apply(duration_minutes) {
        const now = Date.now();
        const filter_duration = duration_minutes * 60 * 1000; // Convert to milliseconds
        
        // Get all file divs that have timestamps
        const all_divs = document.querySelectorAll('div[data-indent]');
        const hidden_files = new Set();
        
        // First pass: identify which files should be hidden
        all_divs.forEach(div => {
            const timestamp = parseInt(div.getAttribute('data-modified'));
            if (timestamp) {
                // This is a file div
                if (filter_duration > 0 && (now - timestamp) > filter_duration) {
                    hidden_files.add(div);
                    div.classList.add('time_hidden');
                } else {
                    div.classList.remove('time_hidden');
                }
            }
        });
        
        // Second pass: hide/show all elements based on file visibility
        all_divs.forEach(div => {
            if (!div.getAttribute('data-modified')) {
                // This is not a file - it's a folder or function
                // Check if it belongs to a hidden file
                let current_file = null;
                let prev = div.previousElementSibling;
                
                // Find the parent file by going backwards
                while (prev) {
                    if (prev.getAttribute('data-modified')) {
                        current_file = prev;
                        break;
                    }
                    const prev_indent = parseInt(prev.getAttribute('data-indent') || '0');
                    const div_indent = parseInt(div.getAttribute('data-indent') || '0');
                    
                    if (prev_indent < div_indent - 1) {
                        // We've gone past the file level
                        break;
                    }
                    prev = prev.previousElementSibling;
                }
                
                if (current_file && hidden_files.has(current_file)) {
                    div.classList.add('time_hidden');
                } else {
                    div.classList.remove('time_hidden');
                }
            }
        });
        
        // Third pass: show folders that contain visible files
        if (filter_duration > 0) {
            const visible_paths = new Set();
            
            all_divs.forEach(div => {
                if (div.getAttribute('data-modified') && !div.classList.contains('time_hidden')) {
                    // This file is visible, mark all its ancestor folders as visible
                    let current = div;
                    while (current) {
                        const current_indent = parseInt(current.getAttribute('data-indent') || '0');
                        
                        // Find parent folder
                        let prev = current.previousElementSibling;
                        while (prev) {
                            const prev_indent = parseInt(prev.getAttribute('data-indent') || '0');
                            if (prev_indent < current_indent && !prev.getAttribute('data-modified')) {
                                // This is a parent folder
                                visible_paths.add(prev);
                                current = prev;
                                break;
                            }
                            prev = prev.previousElementSibling;
                        }
                        
                        if (!prev) break;
                    }
                }
            });
            
            // Show all necessary folders
            visible_paths.forEach(folder => {
                folder.classList.remove('time_hidden');
            });
        }
        
        // Update duplicate detection after time filter
        big_duplicate_update();
    }
    
    // Make save function available globally for utl_shared_client.js to call
    window.page_state_save = state_all_save;
    
    // Global functions for the control buttons
    window.outline_expand_all = function() {
        // Find the current deepest visible level
        const all_divs = document.querySelectorAll('div[data-indent]');
        let max_visible_level = -1;
        
        all_divs.forEach(div => {
            if (div.style.display !== 'none' && !div.classList.contains('search_hidden') && !div.classList.contains('time_hidden')) {
                const indent = parseInt(div.getAttribute('data-indent') || '0');
                if (indent > max_visible_level) {
                    max_visible_level = indent;
                }
            }
        });
        
        // Expand one more level down
        const target_level = max_visible_level + 1;
        
        all_divs.forEach(div => {
            const indent = parseInt(div.getAttribute('data-indent') || '0');
            
            if (indent === target_level) {
                // Check if parent is expanded
                let parent = div.previousElementSibling;
                let parent_expanded = true;
                
                while (parent) {
                    const parent_indent = parseInt(parent.getAttribute('data-indent') || '0');
                    if (parent_indent < indent) {
                        if (parent.getAttribute('data-collapsed') === 'true') {
                            parent_expanded = false;
                        }
                        break;
                    }
                    parent = parent.previousElementSibling;
                }
                
                if (parent_expanded && !div.classList.contains('search_hidden') && !div.classList.contains('time_hidden')) {
                    div.style.display = 'flex';
                }
            } else if (indent === max_visible_level && div.style.display !== 'none') {
                // Expand items at current max level
                div.setAttribute('data-collapsed', 'false');
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('>', '.');
                }
            }
        });
        
        // Update duplicate detection after level changes
        big_duplicate_update();
        
        state_all_save();
    };
    
    window.outline_collapse_all = function() {
        // Find the current deepest visible level
        const all_divs = document.querySelectorAll('div[data-indent]');
        let max_visible_level = -1;
        
        all_divs.forEach(div => {
            if (div.style.display !== 'none' && !div.classList.contains('search_hidden') && !div.classList.contains('time_hidden')) {
                const indent = parseInt(div.getAttribute('data-indent') || '0');
                if (indent > max_visible_level) {
                    max_visible_level = indent;
                }
            }
        });
        
        if (max_visible_level <= 0) return; // Nothing to collapse
        
        // Collapse the deepest level
        all_divs.forEach(div => {
            const indent = parseInt(div.getAttribute('data-indent') || '0');
            
            if (indent === max_visible_level) {
                div.style.display = 'none';
            } else if (indent === max_visible_level - 1 && div.style.display !== 'none') {
                // Mark parent level as collapsed
                div.setAttribute('data-collapsed', 'true');
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('.', '>');
                }
            }
        });
        
        state_all_save();
    };
    
    window.outline_level_1_handle = function() {
        const all_divs = document.querySelectorAll('div[data-indent]');
        
        all_divs.forEach(div => {
            const indent = parseInt(div.getAttribute('data-indent') || '0');
            
            if (indent === 0) {
                // Expand level 0
                div.setAttribute('data-collapsed', 'false');
                div.style.display = 'flex';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('>', '.');
                }
            } else if (indent === 1) {
                // Show level 1 but keep it collapsed
                div.setAttribute('data-collapsed', 'true');
                div.style.display = 'flex';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('.', '>');
                }
                
                // Hide its descendants
                descendant_toggle(div, false);
            } else {
                // Hide deeper levels
                div.style.display = 'none';
            }
        });
        
        // Update duplicate detection after level changes
        big_duplicate_update();
        
        state_all_save();
    };
    
    window.outline_level_2_handle = function() {
        const all_divs = document.querySelectorAll('div[data-indent]');
        
        all_divs.forEach(div => {
            const indent = parseInt(div.getAttribute('data-indent') || '0');
            
            if (indent <= 1) {
                // Expand levels 0 and 1
                div.setAttribute('data-collapsed', 'false');
                div.style.display = 'flex';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('>', '.');
                }
            } else if (indent === 2) {
                // Show level 2 but keep it collapsed
                div.setAttribute('data-collapsed', 'true');
                div.style.display = 'flex';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('.', '>');
                }
                
                // Hide its descendants
                descendant_toggle(div, false);
            } else {
                // Hide deeper levels
                div.style.display = 'none';
            }
        });
        
        // Update duplicate detection after level changes
        big_duplicate_update();
        
        state_all_save();
    };
    
    window.outline_level_3_handle = function() {
        const all_divs = document.querySelectorAll('div[data-indent]');
        
        all_divs.forEach(div => {
            const indent = parseInt(div.getAttribute('data-indent') || '0');
            
            if (indent <= 2) {
                // Expand levels 0, 1, and 2
                div.setAttribute('data-collapsed', 'false');
                div.style.display = 'flex';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('>', '.');
                }
            } else if (indent === 3) {
                // Show level 3 but keep it collapsed
                div.setAttribute('data-collapsed', 'true');
                div.style.display = 'flex';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('.', '>');
                }
                
                // Hide its descendants
                descendant_toggle(div, false);
            } else {
                // Hide deeper levels
                div.style.display = 'none';
            }
        });
        
        // Update duplicate detection after level changes
        big_duplicate_update();
        
        state_all_save();
    };
    
    window.outline_expand_all_handle = function() {
        // Toggle between all expanded and all collapsed
        const all_divs = document.querySelectorAll('div[data-indent]');
        let any_collapsed = false;
        
        // Check if anything is collapsed
        all_divs.forEach(div => {
            if (div.getAttribute('data-collapsed') === 'true' && div.style.display !== 'none') {
                any_collapsed = true;
            }
        });
        
        if (any_collapsed) {
            // Some items are collapsed, so expand all
            all_divs.forEach(div => {
                div.setAttribute('data-collapsed', 'false');
                div.style.display = 'flex';
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('>', '.');
                }
            });
        } else {
            // Everything is expanded, so collapse all to top level
            const top_level_divs = Array.from(all_divs).filter(div => 
                parseInt(div.getAttribute('data-indent') || '0') === 0
            );
            
            // Collapse all top-level items
            top_level_divs.forEach(div => {
                div.setAttribute('data-collapsed', 'true');
                
                const outline_num = div.querySelector('.outline_line_number');
                if (outline_num) {
                    const original = outline_num.getAttribute('data-original') || outline_num.textContent;
                    outline_num.textContent = original.replace('.', '>');
                }
                
                // Hide all descendants
                descendant_toggle(div, false);
            });
        }
        
        // Update duplicate detection after expand/collapse all
        big_duplicate_update();
        
        state_all_save();
    };
    
    // Test localStorage on page load
    console.log('=== Big page localStorage test ===');
    try {
        const test_key = 'big_test_' + Date.now();
        localStorage.setItem(test_key, 'test_value');
        const retrieved = localStorage.getItem(test_key);
        console.log('localStorage test:', retrieved === 'test_value' ? 'PASSED' : 'FAILED');
        localStorage.removeItem(test_key);
    } catch (e) {
        console.error('localStorage test failed:', e);
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    
    // RADICAL FIX: Force save state before ANY page unload/reload
    window.addEventListener('beforeunload', function(e) {
        // Force immediate save
        state_all_save();
        
        // Also try to save via synchronous localStorage
        try {
            const all_divs = document.querySelectorAll('div[data-indent]');
            const quick_state = {};
            all_divs.forEach((div, index) => {
                if (div.getAttribute('data-collapsed') === 'true') {
                    const key = index + '_' + div.textContent.substring(0, 20);
                    quick_state[key] = true;
                }
            });
            localStorage.setItem('big_quick_state', JSON.stringify(quick_state));
        } catch (err) {
            // Ignore errors in emergency save
        }
    });
})();